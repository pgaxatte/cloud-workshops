Deploy backup infrastructure with Terraform
===========================================

At this point, you should have a working infrastructure with 2 instances. This
workshop guides you in the deployment of a third one to act as a backup agent.

You will also generate ansible's inventory from terraform.

First, you need to go back to the project's terraform directory:

.. code:: shell

    $ cd /projects/tf-workshop

Create a third instance
-----------------------

You should be able to complete the following task on your own:

.. admonition:: Task 1

    Add the following resources with the requested features:

    * 1 port on the public network

    * 1 instance for the backup server (name the resource ``backup1``), based
      on ``web1`` or ``db1`` but with only the public interface

    Apply the configuration (there should not be any changes to the existing
    infrastructure, just new resources)

.. note::

    The backup server will not go through the private network in this example so
    you don't need a private port.

Create and attach a volume
--------------------------

To add some storage to the backup server, you will create a 10GB volume and
attach it to the instance.

To do this, you will need two resources in terraform: one for the volume, one
for the attachment.

Here is the volume resource definition to add to your ``main.tf``:

.. code:: terraform

    resource "openstack_blockstorage_volume_v2" "backup1" {
        name = "backup1"
        size = 10
    }

And here is the volume attachment that you need to complete based on the volume
resource and on the backup instance resource:

.. code:: terraform

    resource "openstack_compute_volume_attach_v2" "backup1_vol" {
        instance_id = # reference to the backup instance's resource, using the *id* attribute
        volume_id   = # reference to the volume's resource, using the *id* attribute
    }

.. admonition:: Task 2

    Apply the configuration and connect to the backup instance.

    Ensure you see a new empty disk using ``lsblk`` (which should be named
    ``sdb``).

.. note::

    Terraform only attaches a new disk to the instance so the job of
    partitionning/formatting/mounting this disk is up to Ansible.


Generate ansible's inventory
----------------------------

In the previous workshop you had to manually create the inventory to use the infrastructure you created with terraform.

You can use the ``output`` of terraform to generate this inventory from the information stored in the ``state``.

To do so, create a new file named ``outputs.tf``:

.. code:: terraform

    # Local variables for improved readability
    locals {
        web1_pub_ip = openstack_compute_instance_v2.web1.access_ip_v4
        db1_pub_ip  = openstack_compute_instance_v2.db1.access_ip_v4

        # Assuming you named your resource "backup1"
        backup_pub_ip = openstack_compute_instance_v2.backup1.access_ip_v4
    }

    output "inventory" {
        description = "Ansible inventory generated from the plan"
        value = <<EOF
    # No group for the backup server
    backup ansible_host=${local.backup_pub_ip}

    [web_server]
    web1 ansible_host=${local.web1_pub_ip}

    [database_server]
    db1 ansible_host=${local.db1_pub_ip}

    [wordpress:children]
    database_server
    web_server

    [all:vars]
    ansible_user=ubuntu
    EOF
    }

.. admonition:: Task 3

    Apply the configuration (there should be no change to the existing
    infrastructure).

    Check that the output is correct by using ``terraform output inventory`` and
    comparing it to the ``/projects/ansible/inventory/hosts`` file.

Generate wordpress's group vars
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you take a look at your
``/projetcs/ansible/inventory/group_vars/wordpress/database.yml`` file, you should see
something similar to:

.. code:: yaml

    ---
    wordpress_database: # Private IP of the db1 private interface
    wordpress_webserver: # Private IP of the web1 private interface

This information is actually held by terraform's state: since terraform creates
the private ports, it is the *source of truth* of this information. It is
therefore a good practice to add this information in the inventory file
generated by terraform.

So let's add all this to the ``outputs.tf`` file:

.. code:: terraform

    locals {
        # [...]
        # Add the following lines to extract the private addresses from the ports

        db1_priv_ip  = openstack_networking_port_v2.priv_db1.all_fixed_ips[0]
        web1_priv_ip = openstack_networking_port_v2.priv_web1.all_fixed_ips[0]
    }

    output "inventory" {
        description = "Ansible inventory generated from the plan"
        value = <<EOF
    # [...]

    [all:vars]
    ansible_user=ubuntu

    [wordpress:vars]
    wordpress_database=  # ... complete with the right local variables
    wordpress_webserver= # ...
    EOF
    }

.. note::

    Even if you leave the ``group_vars/wordpress/database.yml`` file as is,
    ansible's `variable precedence <https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#understanding-variable-precedence>`_
    will make ansible choose the variables in the inventory file over the ones
    in the ``group_vars``.

.. admonition:: Task 4

    Apply this configuration and there should still be no changes except the
    output.

Try the generated with ansible
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Replace the old inventory with the new one, generated from terraform:

.. code:: shell

    $ cd /projects/tf-workshop
    $ terraform output -raw inventory > /projects/ansible/inventory/hosts

.. admonition:: Task 5

    Re-run the ``ansible -m ping all`` from ansible's sources directory and verify
    it works properly.

    Then you can apply the ``deploy-wordpress.yml`` playbook again and it should
    work flawlessly.

You can go to the :doc:`next course <04_ansible_deploy_backups>`.
